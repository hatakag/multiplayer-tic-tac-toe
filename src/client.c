#include "client.h"

int sockfd;
volatile int state = NONE;
char *username, *name, *pass;
char grid[BOARD_SIZE][BOARD_SIZE];
char mark;
int turn=0;
int xPos=0, yPos=0;

int main(int argc, char **argv) 
{
  signal(SIGINT, catch_ctrl_c_and_exit);
  //int sockfd;
  struct sockaddr_in servaddr;
  char sendline[MAXLINE], recvline[MAXLINE];
	
  //basic check of the arguments
  //additional checks can be inserted
  if (argc !=2) {
    perror("Usage: TCPClient <IP address of the server"); 
    exit(1);
  }
	
  //Create a socket for the client
  //If sockfd<0 there was an error in the creation of the socket
  if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0) {
    perror("Problem in creating the socket");
    exit(2);
  }
	
  //Creation of the socket
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr= inet_addr(argv[1]);
  servaddr.sin_port =  htons(SERV_PORT); //convert to big-endian order
	
  //Connection of the client to the socket 
  if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr))<0) {
    perror("Problem in connecting to the server");
    exit(3);
  }
 
  // Signal driven I/O mode and NONBlOCK mode so that recv will not block 
  if(fcntl(sockfd, F_SETFL, O_NONBLOCK | O_ASYNC))
    printf("Error in setting socket to async, nonblock mode");  
  
  signal(SIGIO, signio_handler); // assign SIGIO to the handler

  //set this process to be the process owner for SIGIO signal 
  if (fcntl(sockfd, F_SETOWN, getpid()) <0)
    printf("Error in setting own to socket");

  displayLoginScreen();
  while(1) {
    sleep(1);
  }
  //pause();
  exit(0);
}

void signio_handler(int signo)
{
  char buff[1024];
  int n = recv(sockfd, buff, sizeof(buff), 0);
  //if (n>0) // if SIGIO is generated by a data arrival
  //printf("Received from server (%d bytes), content: %s\n",n, buff);
  handleRes(buff);
  memset(buff,0,sizeof(buff));
}

void catch_ctrl_c_and_exit(int sig) {
  if (state==WAITING || state==MARKING) {
    printf("\nCannot quit at this stage - finish the match\n");
  } else {
    send(sockfd, QUIT, sizeof(QUIT), 0);
    printf("__Bye__\n");
    close(sockfd);
    exit(0);
  }
}

void sendLoginReq(char *username, char* password) {
  int len = strlen(username) + strlen(password) + strlen(LOGIN) + 2;
  char *buf = (char*)malloc(sizeof(char)*(len+1));
  strcpy(buf, LOGIN);
  strcat(buf, " ");
  strcat(buf, username);
  strcat(buf, " ");
  strcat(buf, password);
  buf[len] = '\0';
  state = LOGGINGIN;
  send(sockfd, buf, len+1, 0);
  //printf("%s\n", buf);
  free(buf);
}

void sendJoinReq() {
  //printf("%s\n", JOIN);
  state = JOINING;
  send(sockfd, JOIN, sizeof(JOIN), 0);
}

void sendPosReq(int x, int y) {
  int xlen, ylen;
  xlen = snprintf(NULL, 0, "%d", x);
  ylen = snprintf(NULL, 0, "%d", y);
  char *xstr, *ystr;
  xstr = (char*)malloc((xlen+1)*sizeof(char));
  ystr = (char*)malloc((ylen+1)*sizeof(char));
  snprintf(xstr, xlen+1, "%d", x);
  snprintf(ystr, ylen+1, "%d", y);
  int len = strlen(POS) + 2 + xlen + ylen;
  char *buf = (char*)malloc(sizeof(char)*(len+1));
  strcpy(buf, POS);
  strcat(buf, " ");
  strcat(buf, xstr);
  strcat(buf, " ");
  strcat(buf, ystr);
  buf[len] = '\0';
  send(sockfd, buf, len+1, 0);
  //printf("%s\n", buf);
  free(buf);
}

void sendQuitReq() {
  //printf("%s\n", QUIT);
  send(sockfd, QUIT, sizeof(QUIT), 0);
}

void handleRes(char *res) {
  int i = 0;
  char *p = strtok (res, " ");
  char *token[3];
  while (p != NULL) {
    token[i++] = p;
    p = strtok (NULL, " ");
  }
  //printf("%d %s-%s\n", state, token[0], token[1]);
  do {  //need do while to break from if-else in case state changing
    if (state == LOGGINGIN && (strcmp(token[1], LOGIN) == 0)) {
      if (strcmp(token[0], OK) == 0) {
	state = LOGGED;
	//display game menu
	displayMenuScreen();
	break;
      } else {
	//display error ask user to login again
	printf("%s\n", token[2]);
	printf("Press enter to login again\n");
	while(1) {if (getchar()=='\n'&&getchar()=='\n') break;}
	state = NONE;
	displayLoginScreen();
	break;
      }
    } else if (state == JOINING && (strcmp(token[1], JOIN) == 0)) {
      if (strcmp(token[0], OK) == 0) {
	if (strcmp(token[2], "1") == 0) {
	  state = MARKING;
	  mark = 'X';
	  turn = 1;
	} else {
	  state = WAITING;
	  mark = 'O';
	  turn = 2;
	}
	//clear board
	clearBoard();
	//display board
	displayPlayingScreen();
	break;
      } else {
	//display error cannot join
	printf("%s\n", token[2]);
	printf("Press enter to go back to menu\n");
	while(1) {if (getchar()=='\n'&&getchar()=='\n') break;}
	state = LOGGED;
	displayMenuScreen();
	break;
      }
    } else if (state == MARKING && (strcmp(token[1], POS) == 0)) {
      if (strcmp(token[0], OK) == 0) {
	state = WAITING;
	//update board: add new mark & refresh display
	markAt(mark, xPos, yPos);
	displayPlayingScreen();
	break;
      } else {
	//display error invalid mark
	printf("%s\n", token[2]);
	printf("Press enter to re-mark\n");
	while(1) {if (getchar()=='\n'&&getchar()=='\n') break;}
	displayPlayingScreen();
	break;
      }
    } else if (state == WAITING && (strcmp(token[0], POS) == 0)) {
      state = MARKING;
      //update board: opponent mark
      char opponentMark = (mark == 'X') ? 'O' : 'X';
      markAt(opponentMark, atoi(token[1]), atoi(token[2]));
      displayPlayingScreen();
      break;
    } else if ((state == MARKING || state == WAITING) && (strcmp(token[0], END) == 0)) {
      state = LOGGED;
      // display winner if disconnect
      if (checkWin(grid) == 0) {
	printf("\nOther player is disconnected\n");
	displayWinnerScreen(atoi(token[1]));
	break;
      } else {
	displayWinnerScreen(atoi(token[1]));
	break;
      }
    } else {
      // display error - internal server error
      printf("Internal server error\n");
      sendQuitReq();
      printf("\n____GOODBYE____\n");
      exit(0);
    }
  }while(0);
}

void displayLoginScreen() {
  system("clear");
  free(username);free(name);free(pass);
  username = (char*)malloc(sizeof(char)*NAME_LENGTH);
  name = (char*)malloc(sizeof(char)*NAME_LENGTH);
  pass = (char*)malloc(sizeof(char)*STRING_LENGTH);
  printf("Enter your username and password to play\n\n");
  printf("Username: ");
  scanf("%s", name);
  printf("Password: ");
  scanf("%s", pass);
  strcpy(username, name);
  sendLoginReq(name, pass);
}

void displayMenuScreen() {
  system("clear");
  int choice;
  do {
    choice = 0;
    printf("_____MENU_____\n\n");
    printf("1.PLAY\n");
    printf("2.QUIT\n");
    printf("Select: ");scanf("%d",&choice);__fpurge(stdin);
    switch (choice) {
    case 1:
      sendJoinReq();
      displayWaitingScreen();
      break;
    case 2:
      sendQuitReq();
      printf("\n____GOODBYE____\n");
      exit(0);
    default:
      printf("Invalid selection - please select again\n");
      break;
    }
  } while(choice != 2 && choice != 1);
}

void displayPlayingScreen() {
  system("clear");
  printf("\nTIC_TAC_TOE\n\n");
  if (checkWin(grid) == 0) {
    if (state == MARKING) {
      printf("Your turn (%c)\n\n", mark);
    }
    if (state == WAITING) {
      char opponentMark = (mark == 'X') ? 'O' : 'X';
      printf("Opponent turn (%c)\n\n", opponentMark);
    }
  } else printf("\n\n");
  board(grid);
  if (checkWin(grid) == 0) {
    if (state == MARKING) {
      xPos=0, yPos=0;
      printf("\nSelect mark position (x-y): ");
      scanf("%d%*c%d", &xPos, &yPos);
      sendPosReq(xPos, yPos);
    }
    if (state == WAITING) {
      printf("\nWaiting for opponent ...\n");
    }
  } else {
    printf("\nMATCH END\n");
  }
}

void displayWinnerScreen(int winner) {
  if (winner == -1)
    printf("\nDRAW\n");
  else if (winner == turn)
    printf("\nYOU WIN\n");
  else printf("\nYOU LOSE\n");
  printf("\nPress enter to go back to menu\n");
  while(1) {if (getchar()=='\n'&&getchar()=='\n') break;}
  displayMenuScreen();
}

void displayWaitingScreen() {
  printf("Waiting for other player ...\n");
}

void clearBoard() {
  int i,j;
  for (i=0;i<BOARD_SIZE;i++) {
    for (j=0;j<BOARD_SIZE;j++) {
      grid[i][j] = ' ';
    }
  }
}

void markAt(char m, int x, int y) {
  grid[x][y] = m;
}
