#include "client.h"

int sockfd;
int state = NONE;
char username[NAME_LENGTH];
char grid[BOARD_SIZE][BOARD_SIZE];
char mark;
int xPos=0, yPos=0;

int main(int argc, char **argv) 
{
  signal(SIGINT, catch_ctrl_c_and_exit);
  //int sockfd;
  struct sockaddr_in servaddr;
  char sendline[MAXLINE], recvline[MAXLINE];
	
  //basic check of the arguments
  //additional checks can be inserted
  if (argc !=2) {
    perror("Usage: TCPClient <IP address of the server"); 
    exit(1);
  }
	
  //Create a socket for the client
  //If sockfd<0 there was an error in the creation of the socket
  if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0) {
    perror("Problem in creating the socket");
    exit(2);
  }
	
  //Creation of the socket
  memset(&servaddr, 0, sizeof(servaddr));
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr= inet_addr(argv[1]);
  servaddr.sin_port =  htons(SERV_PORT); //convert to big-endian order
	
  //Connection of the client to the socket 
  if (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr))<0) {
    perror("Problem in connecting to the server");
    exit(3);
  }
 
  // Signal driven I/O mode and NONBlOCK mode so that recv will not block 
  if(fcntl(sockfd, F_SETFL, O_NONBLOCK | O_ASYNC))
    printf("Error in setting socket to async, nonblock mode");  
  
  signal(SIGIO, signio_handler); // assign SIGIO to the handler

  //set this process to be the process owner for SIGIO signal 
  if (fcntl(sockfd, F_SETOWN, getpid()) <0)
    printf("Error in setting own to socket");

  displayLoginScreen();
  while(1) {}
  //pause();
  exit(0);
}

void signio_handler(int signo)
{
  char buff[1024];
  int n = recv(sockfd, buff, sizeof(buff), 0);
  //if (n>0) // if SIGIO is generated by a data arrival
  printf("Received from server (%d bytes), content: %s\n",n, buff);
  handleRes(buff);
  memset(buff,0,sizeof(buff));
}

void catch_ctrl_c_and_exit(int sig) {
  send(sockfd, QUIT, sizeof(QUIT), 0);
  printf("Bye\n");
  close(sockfd);
  exit(0);
}

void sendLoginReq(char *username, char* password) {
  int len = strlen(username) + strlen(password) + strlen(LOGIN) + 2;
  char *buf = (char*)malloc(sizeof(char)*(len+1));
  strcpy(buf, LOGIN);
  strcat(buf, " ");
  strcat(buf, username);
  strcat(buf, " ");
  strcat(buf, password);
  buf[len] = '\0';
  state = LOGGINGIN;
  send(sockfd, buf, len+1, 0);
  printf("%s\n", buf);
  free(buf);
}

void sendJoinReq() {
  printf("%s\n", JOIN);
  state = JOINING;
  send(sockfd, JOIN, sizeof(JOIN), 0);
}

void sendPosReq(int x, int y) {
  int xlen, ylen;
  xlen = snprintf(NULL, 0, "%d", x);
  ylen = snprintf(NULL, 0, "%d", y);
  char *xstr, *ystr;
  xstr = (char*)malloc((xlen+1)*sizeof(char));
  ystr = (char*)malloc((ylen+1)*sizeof(char));
  snprintf(xstr, xlen+1, "%d", x);
  snprintf(ystr, ylen+1, "%d", y);
  int len = strlen(POS) + 2 + xlen + ylen;
  char *buf = (char*)malloc(sizeof(char)*(len+1));
  strcpy(buf, POS);
  strcat(buf, " ");
  strcat(buf, xstr);
  strcat(buf, " ");
  strcat(buf, ystr);
  buf[len] = '\0';
  send(sockfd, buf, len+1, 0);
  printf("%s\n", buf);
  free(buf);
}

void sendQuitReq() {
  printf("%s\n", QUIT);
  send(sockfd, QUIT, sizeof(QUIT), 0);
}

void handleRes(char *res) {
  int i = 0;
  char *p = strtok (res, " ");
  char *token[3];
  while (p != NULL) {
    token[i++] = p;
    p = strtok (NULL, " ");
  }
  printf("%d\n", state);
  if (state == LOGGINGIN && (strcmp(token[1], LOGIN) == 0)) {
    if (strcmp(token[0], OK) == 0) {
      state = LOGGED;
      //display game menu
      displayMenuScreen();
    } else {
      //display error ask user to login again
      printf("%s\n", token[2]);
      printf("Press any key to login again\n");
      getchar();
      state = NONE;
      displayLoginScreen();
    }
  } else if (state == JOINING && (strcmp(token[1], JOIN) == 0)) {
    if (strcmp(token[0], OK) == 0) {
      if (strcmp(token[2], "1") == 0) {
	state = MARKING;
	mark = 'X';
      } else {
	state = WAITING;
	mark = 'O';
      }
      //clear board
      clearBoard();
      //display board
      displayPlayingScreen();
    } else {
      //display error cannot join
      printf("%s\n", token[2]);
      printf("Press any key to go back to menu\n");
      getchar();
      state = LOGGED;
      displayMenuScreen();
    }
  } else if (state == MARKING && (strcmp(token[1], POS) == 0)) {
    if (strcmp(token[0], OK) == 0) {
      state = WAITING;
      //update board: add new mark & refresh display
      markAt(mark, xPos, yPos);
      displayPlayingScreen();
    } else {
      //display error invalid mark
      printf("%s\n", token[2]);
      printf("Press any key to re-mark\n");
      getchar();
      displayPlayingScreen();
    }
  } else if (state == WAITING && (strcmp(token[0], POS) == 0)) {
    state = MARKING;
    //update board: opponent mark
    char opponentMark = (mark == 'X') ? 'O' : 'X';
    markAt(opponentMark, atoi(token[1]), atoi(token[2]));
    displayPlayingScreen();
  } else if ((state == MARKING || state == WAITING) && (strcmp(token[0], END) == 0)) {
    // display winner
    printf("%d-%d\n", sockfd, atoi(token[1]));
    if (sockfd == atoi(token[1]))
      printf("\nYou win\n");
    else printf("\nYou lose\n");
    state = LOGGED;
    printf("Press any key to go back to menu\n");
    getchar();
    displayMenuScreen();
  } else {
    // display error - internal server error
    printf("Internal server error\n");
    sendQuitReq();
    printf("\n____GOODBYE____\n");
    exit(0);
  }

}

void displayLoginScreen() {
  memset(username,0,sizeof(username));
  char name[NAME_LENGTH], pass[STRING_LENGTH];
  printf("Username: ");
  scanf("%s", name);
  printf("Password: ");
  scanf("%s", pass);
  sendLoginReq(name, pass);
  strcpy(username, name);
}

void displayMenuScreen() {
  int choice;
  do {
    choice = 0;
    printf("_____MENU_____\n\n");
    printf("1.PLAY\n");
    printf("2.QUIT\n");
    printf("Select: ");scanf("%d",&choice);__fpurge(stdin);
    switch (choice) {
    case 1:
      sendJoinReq();
      displayWaitingScreen();
      break;
    case 2:
      sendQuitReq();
      printf("\n____GOODBYE____\n");
      exit(0);
    default:
      printf("Invalid selection - please select again\n");
      break;
    }
  } while(choice != 2 && choice != 1);
}

void displayPlayingScreen() {
  printf("\nTIC_TAC_TOE\n\n");
  if (state == MARKING) {
    printf("Your turn (%c)\n\n", mark);
  }
  if (state == WAITING) {
    char opponentMark = (mark == 'X') ? 'O' : 'X';
    printf("Opponent turn (%c)\n\n", opponentMark);
  }
  board(grid);
  if (state == MARKING) {
    xPos=0, yPos=0;
    printf("\nSelect mark position (x-y): ");
    scanf("%d%*c%d", &xPos, &yPos);
    sendPosReq(xPos, yPos);
  }
  if (state == WAITING) {
    printf("\nWaiting for opponent ...\n");
  }
}

void displayWaitingScreen() {
  printf("Waiting for other player ...\n");
}

void clearBoard() {
  int i,j;
  for (i=0;i<BOARD_SIZE;i++) {
    for (j=0;j<BOARD_SIZE;j++) {
      grid[i][j] = ' ';
    }
  }
}

void markAt(char m, int x, int y) {
  grid[x][y] = m;
}
